<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Survivor: Universe Pro</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: sans-serif; overflow: hidden; touch-action: none; user-select: none; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .panel { position: absolute; pointer-events: all; background: rgba(10, 10, 30, 0.95); border: 2px solid #00f2ff; border-radius: 15px; padding: 25px; text-align: center; box-sizing: border-box; }
        #menu-ui { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 380px; }
        .char-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin: 15px 0; }
        .char-card { padding: 10px; border: 1px solid #444; cursor: pointer; border-radius: 8px; font-size: 0.8em; transition: 0.2s; }
        .char-card.selected { border-color: #ff00ff; background: rgba(255, 0, 255, 0.2); box-shadow: 0 0 10px #ff00ff; }
        .btn { background: #00f2ff; color: #000; border: none; padding: 15px; font-weight: bold; cursor: pointer; width: 100%; border-radius: 10px; font-size: 1.2em; margin-top: 10px; }
        #stats-bar { position: absolute; top: 15px; left: 15px; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="stats-bar">
            <div style="color:#00f2ff">SCORE: <span id="score">0</span></div>
            <div style="color:#ffd700">GOLD: <span id="gold-display">0</span></div>
        </div>

        <div id="menu-ui" class="panel">
            <h2 style="color:#00f2ff; margin-top:0;">READY TO LAUNCH</h2>
            <div class="char-grid">
                <div id="char-balance" class="char-card selected" onclick="selectChar('balance')"><strong>BAL</strong></div>
                <div id="char-interceptor" class="char-card" onclick="selectChar('interceptor')"><strong>SPD</strong></div>
                <div id="char-tanker" class="char-card" onclick="selectChar('tanker')"><strong>HP</strong></div>
            </div>
            <div style="margin-bottom: 10px; font-size: 0.9em; color: #aaa;">Best Score: <span id="best-score">0</span></div>
            <button class="btn" onclick="startGame()">START GAME</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let saveData = JSON.parse(localStorage.getItem('spaceProData')) || {
            gold: 0, bestScore: 0, selectedId: 'balance'
        };

        const save = () => localStorage.setItem('spaceProData', JSON.stringify(saveData));

        let gameActive = false, score = 0, frame = 0;
        let bullets = [], enemies = [];
        const player = { x: 0, y: 0, targetX: 0, targetY: 0, size: 15 };

        // 소리 재생용 오디오 컨텍스트
        let audioCtx;

        function playSound(freq, type, duration, vol) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + duration);
        }

        function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            player.x = player.targetX = canvas.width / 2;
            player.y = player.targetY = canvas.height * 0.8;
            document.getElementById('gold-display').innerText = saveData.gold;
            document.getElementById('best-score').innerText = saveData.bestScore;
        }

        window.selectChar = (id) => {
            saveData.selectedId = id;
            document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
            document.getElementById('char-' + id).classList.add('selected');
            save();
        };

        window.startGame = () => {
            // 브라우저 소리 잠금 해제
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            document.getElementById('menu-ui').style.display = 'none';
            score = 0; frame = 0; bullets = []; enemies = [];
            gameActive = true;
            playSound(440, 'sine', 0.2, 0.1); // 시작음
            loop();
        };

        const updateTarget = (clientX, clientY, isTouch) => {
            player.targetX = clientX;
            // 모바일은 손가락 위 60px 지점에 위치 (가려짐 방지)
            player.targetY = isTouch ? clientY - 60 : clientY;
        };

        window.addEventListener('mousemove', (e) => updateTarget(e.clientX, e.clientY, false));
        window.addEventListener('touchmove', (e) => {
            if(gameActive) e.preventDefault();
            updateTarget(e.touches[0].clientX, e.touches[0].clientY, true);
        }, { passive: false });

        function loop() {
            if (!gameActive) return;
            frame++;

            // 배경 클리어
            ctx.fillStyle = '#00040a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 움직임 개선 (Lerp 속도 향상: 0.1 -> 0.3)
            player.x += (player.targetX - player.x) * 0.3;
            player.y += (player.targetY - player.y) * 0.3;

            // 플레이어 그리기
            ctx.fillStyle = '#00f2ff';
            ctx.beginPath();
            ctx.moveTo(player.x, player.y - 15);
            ctx.lineTo(player.x - 12, player.y + 12);
            ctx.lineTo(player.x + 12, player.y + 12);
            ctx.fill();

            // 총알 발사
            if (frame % 8 === 0) {
                bullets.push({x: player.x, y: player.y - 15});
                playSound(800, 'sine', 0.05, 0.02);
            }

            bullets.forEach((b, bi) => {
                b.y -= 15;
                ctx.fillStyle = '#fff';
                ctx.fillRect(b.x - 1, b.y, 2, 10);
                if (b.y < 0) bullets.splice(bi, 1);
            });

            // 적 생성
            if (frame % 25 === 0) {
                enemies.push({x: Math.random() * canvas.width, y: -20, s: 15 + Math.random()*15});
            }

            enemies.forEach((e, ei) => {
                e.y += 4 + (score/5000);
                ctx.fillStyle = '#ff3366';
                ctx.beginPath(); ctx.arc(e.x, e.y, e.s, 0, Math.PI*2); ctx.fill();

                // 총알 충돌
                bullets.forEach((b, bi) => {
                    if (Math.hypot(b.x - e.x, b.y - e.y) < e.s) {
                        enemies.splice(ei, 1);
                        bullets.splice(bi, 1);
                        score += 100;
                        saveData.gold += 1;
                        playSound(150, 'sawtooth', 0.1, 0.05); // 파괴음
                    }
                });

                // 플레이어 충돌
                if (Math.hypot(player.x - e.x, player.y - e.y) < e.s + 10) {
                    gameOver();
                }
                
                if (e.y > canvas.height) enemies.splice(ei, 1);
            });

            document.getElementById('score').innerText = score;
            document.getElementById('gold-display').innerText = saveData.gold;
            requestAnimationFrame(loop);
        }

        function gameOver() {
            gameActive = false;
            playSound(100, 'square', 0.5, 0.2); // 패배음
            if (score > saveData.bestScore) saveData.bestScore = score;
            save();
            alert("GAME OVER! Score: " + score);
            location.reload();
        }

        window.addEventListener('resize', init);
        window.onload = init;
    </script>
</body>
</html>                    <strong>Balanced</strong><br>SPD: 5/ATK: 5
                </div>
                <div id="char-interceptor" class="char-card" onclick="selectChar('interceptor')">
                    <strong>Swift</strong><br>SPD: 9/ATK: 3
                </div>
                <div id="char-tanker" class="char-card" onclick="selectChar('tanker')">
                    <strong>Titan</strong><br>SPD: 2/ATK: 8
                </div>
            </div>

            <div id="shop-container">
                <div class="shop-item" onclick="buyUpgrade('atkSpd')">Rapid Fire (Lv.<span id="lv-atkSpd">0</span>) - <span id="pr-atkSpd">200</span>G</div>
                <div class="shop-item" onclick="buyUpgrade('dmg')">Power Beam (Lv.<span id="lv-dmg">0</span>) - <span id="pr-dmg">300</span>G</div>
            </div>

            <div class="rank-list" id="rank-list"></div>
            
            <button class="btn" style="margin-top:15px;" onclick="startGame()">LAUNCH MISSION</button>
            <p style="font-size: 10px; color: #666;">SPACE or Touch Score: SUPERNOVA</p>
        </div>

        <div id="skill-ui"><div id="skill-fill"></div></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let saveData = JSON.parse(localStorage.getItem('spaceFinalData')) || {
            gold: 0, ranks: [], ghostPath: [],
            upgrades: { atkSpd: 0, dmg: 0 },
            selectedId: 'balance'
        };

        const save = () => localStorage.setItem('spaceFinalData', JSON.stringify(saveData));

        let gameActive = false, score = 0, frame = 0, skillGauge = 0;
        let bullets = [], enemies = [], items = [], currentPath = [];
        const player = { x: 0, y: 0, targetX: 0, targetY: 0, size: 15, type: 'balance', shield: false };

        const chars = {
            balance: { speed: 0.15, color: '#00f2ff', shield: false },
            interceptor: { speed: 0.3, color: '#ff00ff', shield: false },
            tanker: { speed: 0.07, color: '#ff4d4d', shield: true }
        };

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(f, t, d, v=0.1) {
            try {
                const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
                o.type = t; o.frequency.setValueAtTime(f, audioCtx.currentTime);
                g.gain.setValueAtTime(v, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+d);
                o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+d);
            } catch(e) {}
        }

        function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            player.x = player.targetX = canvas.width / 2;
            player.y = player.targetY = canvas.height * 0.8;
            updateUI();
        }

        function updateUI() {
            document.getElementById('gold-display').innerText = saveData.gold;
            const rList = document.getElementById('rank-list');
            rList.innerHTML = "<strong>TOP RECORDS:</strong><br>" + 
                (saveData.ranks.length ? saveData.ranks.slice(0, 3).map((s, i) => `${i+1}. ${s} pts`).join('<br>') : "No data");
            
            ['atkSpd', 'dmg'].forEach(id => {
                document.getElementById(`lv-${id}`).innerText = saveData.upgrades[id];
                document.getElementById(`pr-${id}`).innerText = (saveData.upgrades[id] + 1) * 200;
            });

            document.querySelectorAll('.char-card').forEach(c => {
                c.classList.toggle('selected', c.id === 'char-' + saveData.selectedId);
            });
        }

        window.selectChar = (id) => {
            saveData.selectedId = id;
            playSfx(400, 'sine', 0.1);
            updateUI();
            save();
        };

        window.buyUpgrade = (id) => {
            const price = (saveData.upgrades[id] + 1) * 200;
            if (saveData.gold >= price) {
                saveData.gold -= price;
                saveData.upgrades[id]++;
                playSfx(600, 'sine', 0.2);
                save();
                updateUI();
            }
        };

        window.startGame = () => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            document.getElementById('menu-ui').style.display = 'none';
            score = 0; frame = 0; skillGauge = 0; bullets = []; enemies = []; currentPath = [];
            player.type = saveData.selectedId;
            player.shield = chars[player.type].shield;
            gameActive = true;
            loop();
        };

        const handleInput = (e) => {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            player.targetX = clientX;
            player.targetY = clientY - (e.touches ? 60 : 0);
        };

        window.addEventListener('mousemove', handleInput);
        window.addEventListener('touchmove', (e) => { if(gameActive) e.preventDefault(); handleInput(e); }, { passive: false });
        
        window.addEventListener('keydown', (e) => { if(e.code === 'Space') useSkill(); });
        canvas.addEventListener('touchstart', (e) => { if(e.touches.length > 1) useSkill(); });

        function useSkill() {
            if (skillGauge >= 100) {
                skillGauge = 0;
                playSfx(100, 'sawtooth', 0.5, 0.3);
                score += enemies.length * 50;
                enemies = [];
            }
        }

        function loop() {
            if (!gameActive) return;
            frame++;
            ctx.fillStyle = 'rgba(0, 5, 15, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            currentPath.push({x: player.x, y: player.y});
            if (skillGauge < 100) skillGauge += 0.1;
            document.getElementById('skill-fill').style.width = skillGauge + '%';

            // 고스트 (기존 기록 재현)
            if (saveData.ghostPath && saveData.ghostPath[frame]) {
                const gp = saveData.ghostPath[frame];
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.beginPath(); ctx.arc(gp.x, gp.y, 8, 0, Math.PI*2); ctx.fill();
            }

            // 플레이어 이동 및 물리
            player.x += (player.targetX - player.x) * chars[player.type].speed;
            player.y += (player.targetY - player.y) * chars[player.type].speed;

            ctx.fillStyle = chars[player.type].color;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y - 15);
            ctx.lineTo(player.x - 12, player.y + 12);
            ctx.lineTo(player.x + 12, player.y + 12);
            ctx.fill();
            if (player.shield) {
                ctx.strokeStyle = '#fff'; ctx.beginPath(); ctx.arc(player.x, player.y, 20, 0, Math.PI*2); ctx.stroke();
            }

            // 사격
            const rate = Math.max(5, 12 - saveData.upgrades.atkSpd);
            if (frame % rate === 0) {
                bullets.push({x: player.x, y: player.y - 15});
                playSfx(800, 'sine', 0.05, 0.01);
            }

            bullets.forEach((b, bi) => {
                b.y -= 15;
                ctx.fillStyle = '#fff'; ctx.fillRect(b.x-1, b.y, 2, 10);
                if (b.y < 0) bullets.splice(bi, 1);
            });

            // 적 생성 및 난이도
            if (frame % Math.max(8, 30 - Math.floor(score/2000)) === 0) {
                enemies.push({x: Math.random() * canvas.width, y: -20, s: 15+Math.random()*15, h: 1 + Math.floor(score/5000)});
            }

            enemies.forEach((e, ei) => {
                e.y += 3 + (score/4000);
                ctx.fillStyle = '#ff3366'; ctx.beginPath(); ctx.arc(e.x, e.y, e.s, 0, Math.PI*2); ctx.fill();

                if (Math.hypot(player.x - e.x, player.y - e.y) < e.s + 10) {
                    if (player.shield) { player.shield = false; enemies.splice(ei, 1); playSfx(200, 'square', 0.2); }
                    else gameOver();
                }

                bullets.forEach((b, bi) => {
                    if (Math.hypot(b.x - e.x, b.y - e.y) < e.s) {
                        e.h -= (1 + saveData.upgrades.dmg);
                        bullets.splice(bi, 1);
                        if(e.h <= 0) {
                            enemies.splice(ei, 1); score += 100; saveData.gold += 2;
                            playSfx(150, 'sawtooth', 0.1, 0.05);
                        }
                    }
                });
                if (e.y > canvas.height) enemies.splice(ei, 1);
            });

            document.getElementById('score').innerText = score;
            document.getElementById('gold-display').innerText = saveData.gold;
            requestAnimationFrame(loop);
        }

        function gameOver() {
            gameActive = false;
            saveData.ranks.push(score);
            saveData.ranks.sort((a,b) => b-a);
            if (score >= Math.max(...saveData.ranks, 0)) saveData.ghostPath = currentPath;
            save();
            alert("GAME OVER\nSCORE: " + score);
            location.reload();
        }

        window.addEventListener('resize', init);
        window.onload = init;
    </script>
</body>
</html>
